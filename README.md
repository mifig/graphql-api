# üíé RAILS API + üï∏Ô∏è GRAPHQL
<span style="background: rgba(100, 120, 100); border-radius: 10px; padding: 8px 12px;">***v0.1** - 20.08.2024*</span> 

This project aims at providing detailed guidelines to create a Rails API with GraphQL.

It will cover the following sections:

1. Rails API creation
2. GraphQL setup
3. GraphQL types & Active Record Models
4. GraphQL resolvers
5. GraphQL relations
6. GraphQL mutations
7. Authentication with JWT in a Rails API + GraphQL context

> üö® This tutorial assumes a basic knowledge of graphQL operations. Refer to [this tutorial](https://www.youtube.com/playlist?list=PL4cUxeGkcC9gUxtblNUahcsg0WLxmrK_y) to gain an understanding of graphQL before jumping to this project. It should take approximately 2 hours.

**üîî Note** 
This project uses the following software versions:
- `Ruby`: 3.1.2p20
- `Rails`: 7.1.3.4
- `GraphQL`: 2.3.14

## 1. Rails API creation

Creation of Rails API with postgresql DB:
```sh
rails new NAMEOFAPP --api -d postgresql
```

## 2. GraphQL setup

Add graphql gem to your `gemfile.rb`:
```ruby
gem 'graphql'
```

Install the gem through the terminal:
```sh
bundle install
```

Run the graphql installer that will generate the endpoint of your graphql (in /graphql, check the `routes.rb`) through the terminal:
```sh
rails generate graphql:install
```

Create beforehand the folder structures that will facilitate the organization of a graphql project, with a clear separation of concerns. In `app` > `graphql`:
1. Create a folder `resolvers`;
2. Inside the `resolvers` folder, create the file `base_resolver.rb`:
  ```ruby
  module Resolvers
    class BaseResolver < GraphQL::Schema::Resolver
    end
  end
  ```
3. Inside the `types` folder, create the folders:
  - `models` (where all the types related to your Active Record models will live)
  - `enums` (where all the enums relative to Active Record enums will live)
  - `inputs` (where all the inputs for the mutations will live)

<br>

### Final folder structure
Your folder structure should now look like this (*of course, all the files and folders automatically generated by the graphql installer will also be there*):
- `app`
  - `graphql`
    - `mutations`
    - `resolvers`
    - `types`
      - `enums`
      - `inputs`
      - `models`

## 3. GraphQL types & Active Record Models
Before jumping to graphQL, start by creating the DB, some models and seeds so that we can quickstart our project.

### Generate Active Record models:
These 3 models will ensure we also understand how to manage relations between models in GraphQL.
```sh
rails g model user first_name last_name email
```
```sh
rails g model blog title description:text user:references
```
```sh
rails g model review content:text user:references blog:references
```

#### User Model
Add in the `user.rb` model the reviews and blogs associations:
```ruby
class User < ApplicationRecord
  has_many :blogs, dependent: :destroy
  has_many :reviews, dependent: :destroy
  
  before_save { self.email = email.downcase }

  def full_name
    "#{first_name} #{last_name}"
  end
end
```

#### Blog Model
Add in the `user.rb` model the reviews and blogs associations:
```ruby
class Blog < ApplicationRecord
  belongs_to :user
  has_many :reviews, dependent: :destroy
end
```

#### Review Model
The review model you don't need to alter, as it comes already with the correct associations to both user and blog models, created automatically when the rails generator was ran for the review model.

### Create some Seeds:
Now generate some seeds in the `seeds.rb` file so that we have some data to test our implementations (you can use the `faker` gem):
```ruby
User.destroy_all
Blog.destroy_all
Review.destroy_all

5.times do
  first_name = Faker::Name.first_name
  User.create!(first_name:, last_name: Faker::Name.last_name, email: "#{first_name}@test.com")
end

20.times do
  Blog.create!(title: Faker::Book.title, description: Faker::Lorem.paragraphs(number: 3), user: User.find(User.ids.sample))
end

30.times do 
  Review.create!(content: Faker::GreekPhilosophers.quote, user: User.find(User.ids.sample), blog: Blog.find(Blog.ids.sample))
end
```

### Create your DB
Now create, migrate and run the seeds in the terminal:
```sh
rails db:create db:migrate db:seed
```

Your DB is now setup.

### Generate the graphQL types
The graphQL types will ensure that the data type of each model is visible in your front-end app, ensuring it's correct usage both in back and front-end.

Let's start by creating the necessary graphQL objects to ensure we can make a query to get all blogs. The query would look like this:

```graphql
query Blogs {
  blogs {
    title
    description
  }
}
```

In order to be able to perform a query to the graphql endpoint (`/graphql` defined in the `routes.rb`), we need to generate the blogs type:
```sh
rails g graphql:object blog
```

This will generate a `blog_type.rb` in the `types` folder:
```ruby
module Types
  class BlogType < Types::BaseObject
    field :id, ID, null: false
    field :title, String
    field :description, String
    field :user_id, Integer
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false
  end
end
```

We need to move the file to the `types` > `models` folder and add a module `Models` around it:
```ruby
module Types
  module Models
    class BlogType < Types::BaseObject
      field :id, ID, null: false
      field :title, String
      field :description, String
      field :user_id, Integer
      field :created_at, GraphQL::Types::ISO8601DateTime, null: false
      field :updated_at, GraphQL::Types::ISO8601DateTime, null: false
    end
  end
end
```

We cannot yet do the intended query, because we need to state how to resolve this query in the resolvers.

## 4. GraphQL resolvers

### Get All Blogs
Create a resolver for the getting all the blogs in the `resolvers` folder, call it `blogs_resolver.rb`:
```ruby
module Resolvers
  class BlogsResolver < BaseResolver
    description "Get all blogs."

    type [Types::Models::BlogType], null: false

    def resolve
      ::Blog.all
    end
  end
end
```

Now we just need to add in the `query_type.rb` the field **blogs** pointing to the resolver `blogs_resolver`:
```ruby
field :blogs, resolver: Resolvers::BlogsResolver
``` 

We can now do the query to the graphQL endpoint and it will return to us the specified fields for all the blogs.

### Get a Blog by ID
Same process, create a resolver for getting the blog under `resolvers`, called `blog_resolver.rb`:
```ruby
module Resolvers
  class BlogResolver < BaseResolver
    description "Get a blog by ID."
    
    argument :id, ID, required: true

    type Types::Models::BlogType, null: true
    
    def resolve(id:)
      ::Blog.find_by(id:)
    end
  end
end
```

Now we just need to add in the `query_type.rb` the field **blog** pointing to the resolver `blog_resolver`:
```ruby
field :blog, resolver: Resolvers::BlogResolver
``` 

We can now get a blog info by providing its id:
```graphql
query Blog {
  blog(id: 1) {
    title
    description
  }
}
```

## 5. GraphQL relations
Let's now try to get the user associated to the blogs. We want to be able to do a query like this:
```graphql
query Blogs {
  blogs {
    title
    description
    user {
      id
      email
      fullName
    }
  }
}
```

### Add the relation in the types
In the `blog_type.rb` substitute the `user_id` field by:
```ruby
field :user, UserType, null: false
```

This will ensure the relation is established and the user type is of UserType (that we already created by doing `rails g graphql:object user`).

We can now do the desired query with no problems.

### What if we want to get all blogs associated to that user?
Imagine we now wanted to get all blogs, each blog showing the user that wrote it but also every blogs associated to that user as well. We want to be able to do a query like this:
```graphql
query Blogs {
  blogs {
    title
    description
    user {
      id
      email
      fullName
      blogs {
        id
        title
      }
    }
  }
}
```

For that, we just need to add the following field to the `user_type.rb`:
```ruby
field :blogs, [BlogType]
``` 

Now we can either get the user associated to a blog, or the blogs associated to a user.

## 6. GraphQL mutations
### 6.1 CREATE
To generate a create mutation, for example to create a new blog, we can use graphql generator in the command line:

```sh
rails g graphql:mutation_create blog
```

This will:
- Create the `blog_create.rb` mutation file within `app/graphql/mutations`;
- Add the ruby code

  ```ruby
  field :blog_create, mutation: Mutations::BlogCreate
  ``` 
  within the `mutation_type.rb` file, creating a field mapped to this resolver for the mutation type, which is present in the `app/graphql/types` folder.

Let's now generate the input attributes that we accept when creating a blog. We can do this using graphql generator as well:
```ruby
rails g graphql:input inputs/create_blog
```

In the created `create_blog_input.rb` file, add the accepted arguments. Also add the `Module Inputs` and change the name of the file and class to `CreateBlogInput`:
```ruby
module Types
  module Inputs
    class CreateBlogInput < Types::BaseInputObject
      description "Attributes for creating a blog"

      argument :title, String, required: true
      argument :description, String, required: false
      argument :user_id, ID, required: true
    end
  end
end
```

Now we just need to edit the mutation resolver to tailor our needs:
```ruby
module Mutations
  class BlogCreate < BaseMutation
    description "Creates a new blog"

    field :blog, Types::Models::BlogType, null: false

    argument :data, Types::Inputs::CreateBlogInput, required: true

    def resolve(data:)
      blog = ::Blog.new(**data)
      raise GraphQL::ExecutionError.new "Error creating blog", extensions: blog.errors.to_hash unless blog.save

      { blog: blog }
    end
  end
end
```

Finally, we are able to do the intended query:
```graphql
mutation CreateBlog($data: CreateBlogInput!) {
  blogCreate(input: { data: $data }) {
    blog {
      createdAt
      description
      id
      title
      updatedAt
    }
  }
}
```

with the variables:
```json
{
  "data": {
    "title": "My New Blog",
    "description": "This is a blog post about GraphQL",
    "userId": 1
  }
}
```

### 6.2 DESTROY
We will follow the same process, but now for destroying a blog:
```sh
rails g graphql:mutation_delete blog
```

The `field :blog_delete, mutation: Mutations::BlogDelete` will automatically be added to the `mutation_type.rb` file.

In the mutation `blog_delete.rb` just add:
```ruby
module Mutations
  class BlogDelete < BaseMutation
    description "Deletes a blog by ID"

    field :blog, Types::Models::BlogType, null: false

    argument :id, ID, required: true

    def resolve(id:)
      blog = ::Blog.find(id)
      raise GraphQL::ExecutionError.new "Error deleting blog", extensions: blog.errors.to_hash unless blog.destroy!

      { blog: blog }
    end
  end
end
```

We can now destroy a blog, as such:
```graphql
mutation DestroyBlog($id: ID!) {
  blogDelete(input: { id: $id }) {
    blog {
      title
      description
    }
  }
}
```
with the id variable:
```json
{
    "id": 23
}
```

### 6.3 UPDATE
Create mutation:
```sh
rails g graphql:mutation_update blog
```

Edit mutation file:
```ruby
module Mutations
  class BlogUpdate < BaseMutation
    description "Updates a blog by id"

    field :blog, Types::Models::BlogType, null: false

    argument :id, ID, required: true
    argument :data, Types::Inputs::UpdateBlogInput, required: true


    def resolve(id:, data:)
      blog = ::Blog.find(id)
      raise GraphQL::ExecutionError.new "Error updating blog", extensions: blog.errors.to_hash unless blog.update(**data)

      { blog: blog }
    end
  end
end
```

Create Input for blog in `update_blog_input.rb`:
```ruby
module Types
  module Inputs
    class UpdateBlogInput < Types::BaseInputObject
      description "Attributes for updating a blog"

      argument :title, String, required: false
      argument :description, String, required: false
      argument :user_id, ID, required: false
    end
  end
end
```

Now we can do the query to update a blog:
```graphql
mutation UpdateBlog($id: ID!, $data: UpdateBlogInput!) {
  blogUpdate(input: { id: $id, data: $data }) {
    blog {
      title
      description
    }
  }
}
```
with variables:
```json
{
    "data": {
        "title": "Newer blog üòÑ"
    },
    "id": 26
}
```

## 7. Authentication with JWT in a Rails API + GraphQL context
In order to have the authentication functionality up and running, the first thing we need to do is to:
- Comment out the `gem "bcrypt", "~> 3.1.7"` in our gemfile and run `bundle install` in the command line.

We now need to add the `has_secure_password` macro (available within Rails) in our `User` model, which will allow us to encrypt the authentication info of our users:
```ruby
class User < ApplicationRecord
  has_secure_password
  
  has_many :blogs, dependent: :destroy
  has_many :reviews, dependent: :destroy
  
  before_save { self.email = email.downcase }

  def full_name
    "#{first_name} #{last_name}"
  end
end
```

We also need to add the `password_digest` column (String) to the `User` model so that we can store the digested password in our DB in the users table:
```sh
rails g migration AddPasswordDigestToUsers password_digest
```
and run the migration with `rails db:migrate`.

With the `has_secure_password` method we now have access to the `password` and `password_confirmation` instance methods that will allow us to implement the **log in** and **sign up** functionalities.

We just need now to add the `gem 'jwt'` to our gemfile so that we can authenticate our users using JSON Web Tokens. Then run `bundle install` in the command line to install the gem.

## References
- [GraphQL Gem](https://graphql-ruby.org/)
- [How To GraphQL-Ruby Tutorial](https://www.howtographql.com/graphql-ruby/0-introduction/)
- [Data Manipulation: A Dive into GraphQL Mutations in Rails 7 API](https://medium.com/simform-engineering/data-manipulation-a-dive-into-graphql-mutations-in-rails-7-api-bca1f7f00bab)
- [Unlocking GraphQL's Power with Rails: What No One's Told You Yet!](https://www.youtube.com/watch?v=nnHYfNRGFKQ)
- [Rails magic: has_secure_password](https://medium.com/geekculture/rails-magic-has-secure-password-a9bf0167642d)
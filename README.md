# üíé RAILS API + üï∏Ô∏è GRAPHQL
<span style="background: rgba(100, 120, 100); border-radius: 10px; padding: 8px 12px;">***v0.1** - 20.08.2024*</span> 

This project aims at providing detailed guidelines to create a Rails API with GraphQL.

It will cover the following sections:

1. Rails API creation
2. GraphQL setup
3. GraphQL types & Active Record Models
4. GraphQL resolvers
5. GraphQL encrypt IDs
6. GraphQL relations
7. GraphQL mutations
8. Authentication with JWT in a Rails API + GraphQL context
9. Pundit integration with GraphQL for authorization

> üö® This tutorial assumes a basic knowledge of graphQL operations. Refer to [this tutorial](https://www.youtube.com/playlist?list=PL4cUxeGkcC9gUxtblNUahcsg0WLxmrK_y) to gain an understanding of graphQL before jumping to this project. It should take approximately 2 hours.

**üîî Note** 
This project uses the following software versions:
- `Ruby`: 3.1.2p20
- `Rails`: 7.1.3.4
- `GraphQL`: 2.3.14

## 1. Rails API creation

Creation of Rails API with postgresql DB:
```sh
rails new NAMEOFAPP --api -d postgresql
```

## 2. GraphQL setup

Add graphql gem to your `gemfile.rb`:
```ruby
gem 'graphql'
```

Install the gem through the terminal:
```sh
bundle install
```

Run the graphql installer that will generate the endpoint of your graphql (in /graphql, check the `routes.rb`) through the terminal:
```sh
rails generate graphql:install
```

Create beforehand the folder structures that will facilitate the organization of a graphql project, with a clear separation of concerns. In `app` > `graphql`:
1. Create a folder `resolvers`;
2. Inside the `resolvers` folder, create the file `base_resolver.rb`:
  ```ruby
  module Resolvers
    class BaseResolver < GraphQL::Schema::Resolver
    end
  end
  ```
3. Inside the `types` folder, create the folders:
  - `models` (where all the types related to your Active Record models will live)
  - `enums` (where all the enums relative to Active Record enums will live)
  - `inputs` (where all the inputs for the mutations will live)

<br>

### Final folder structure
Your folder structure should now look like this (*of course, all the files and folders automatically generated by the graphql installer will also be there*):
- `app`
  - `graphql`
    - `mutations`
    - `resolvers`
    - `types`
      - `enums`
      - `inputs`
      - `models`

## 3. GraphQL types & Active Record Models
Before jumping to graphQL, start by creating the DB, some models and seeds so that we can quickstart our project.

### Generate Active Record models:
These 3 models will ensure we also understand how to manage relations between models in GraphQL.
```sh
rails g model user first_name last_name email
```
```sh
rails g model blog title description:text user:references
```
```sh
rails g model review content:text user:references blog:references
```

#### User Model
Add in the `user.rb` model the reviews and blogs associations:
```ruby
class User < ApplicationRecord
  has_many :blogs, dependent: :destroy
  has_many :reviews, dependent: :destroy
  
  before_save { self.email = email.downcase }

  def full_name
    "#{first_name} #{last_name}"
  end
end
```

#### Blog Model
Add in the `user.rb` model the reviews and blogs associations:
```ruby
class Blog < ApplicationRecord
  belongs_to :user
  has_many :reviews, dependent: :destroy
end
```

#### Review Model
The review model you don't need to alter, as it comes already with the correct associations to both user and blog models, created automatically when the rails generator was ran for the review model.

### Create some Seeds:
Now generate some seeds in the `seeds.rb` file so that we have some data to test our implementations (you can use the `faker` gem):
```ruby
User.destroy_all
Blog.destroy_all
Review.destroy_all

5.times do
  first_name = Faker::Name.first_name
  User.create!(first_name:, last_name: Faker::Name.last_name, email: "#{first_name}@test.com")
end

20.times do
  Blog.create!(title: Faker::Book.title, description: Faker::Lorem.paragraphs(number: 3), user: User.find(User.ids.sample))
end

30.times do 
  Review.create!(content: Faker::GreekPhilosophers.quote, user: User.find(User.ids.sample), blog: Blog.find(Blog.ids.sample))
end
```

### Create your DB
Now create, migrate and run the seeds in the terminal:
```sh
rails db:create db:migrate db:seed
```

Your DB is now setup.

### Generate the graphQL types
The graphQL types will ensure that the data type of each model is visible in your front-end app, ensuring it's correct usage both in back and front-end.

Let's start by creating the necessary graphQL objects to ensure we can make a query to get all blogs. The query would look like this:

```graphql
query Blogs {
  blogs {
    title
    description
  }
}
```

In order to be able to perform a query to the graphql endpoint (`/graphql` defined in the `routes.rb`), we need to generate the blogs type:
```sh
rails g graphql:object blog
```

This will generate a `blog_type.rb` in the `types` folder:
```ruby
module Types
  class BlogType < Types::BaseObject
    field :id, ID, null: false
    field :title, String
    field :description, String
    field :user_id, Integer
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false
  end
end
```

We need to move the file to the `types` > `models` folder and add a module `Models` around it:
```ruby
module Types
  module Models
    class BlogType < Types::BaseObject
      field :id, ID, null: false
      field :title, String
      field :description, String
      field :user_id, Integer
      field :created_at, GraphQL::Types::ISO8601DateTime, null: false
      field :updated_at, GraphQL::Types::ISO8601DateTime, null: false
    end
  end
end
```

We cannot yet do the intended query, because we need to state how to resolve this query in the resolvers.

## 4. GraphQL resolvers

### Get All Blogs
Create a resolver for the getting all the blogs in the `resolvers` folder, call it `blogs_resolver.rb`:
```ruby
module Resolvers
  class BlogsResolver < BaseResolver
    description "Get all blogs."

    type [Types::Models::BlogType], null: false

    def resolve
      ::Blog.all
    end
  end
end
```

Now we just need to add in the `query_type.rb` the field **blogs** pointing to the resolver `blogs_resolver`:
```ruby
field :blogs, resolver: Resolvers::BlogsResolver
``` 

We can now do the query to the graphQL endpoint and it will return to us the specified fields for all the blogs.

### Get a Blog by ID
Same process, create a resolver for getting the blog under `resolvers`, called `blog_resolver.rb`:
```ruby
module Resolvers
  class BlogResolver < BaseResolver
    description "Get a blog by ID."
    
    argument :id, ID, required: true

    type Types::Models::BlogType, null: true
    
    def resolve(id:)
      ::Blog.find_by(id:)
    end
  end
end
```

Now we just need to add in the `query_type.rb` the field **blog** pointing to the resolver `blog_resolver`:
```ruby
field :blog, resolver: Resolvers::BlogResolver
``` 

We can now get a blog info by providing its id:
```graphql
query Blog {
  blog(id: 1) {
    title
    description
  }
}
```

## 5. GraphQL encrypt IDs
Add method `id` to `base.object.rb` type:
```ruby
module Types
  class BaseObject < GraphQL::Schema::Object
    edge_type_class(Types::BaseEdge)
    connection_type_class(Types::BaseConnection)
    field_class Types::BaseField
    
    def id
      object.to_gid_param
    end
  end
end
```

Update resolvers or mutations to handle the id (substitute id for user_id):
```ruby
module Resolvers
  class UserResolver < BaseResolver
    description "Get a user by ID."
    
    argument :user_id, ID, required: true, loads: Types::Models::UserType

    type Types::Models::UserType, null: true
    
    def resolve(user:)
      user
    end
  end
end
```

Change schema method `self.resolve_type` to:
```ruby
def self.resolve_type(abstract_type, obj, ctx)
  # TODO: Implement this method
  # to return the correct GraphQL object type for `obj`
  abstract_type
end
```

Queries will now return an encrypted id, and we need to send the encrypted id as well to get the instance (we also need to user user_id now instead of id):
```graphql
query User {
  user(userId: "Z2lkOi8vZ3JhcGhxbC1hcGkvVXNlci8xMA") {
    createdAt
    email
    firstName
    fullName
    id
    lastName
    updatedAt
  }
}
```

## 6. GraphQL relations
Let's now try to get the user associated to the blogs. We want to be able to do a query like this:
```graphql
query Blogs {
  blogs {
    title
    description
    user {
      id
      email
      fullName
    }
  }
}
```

### Add the relation in the types
In the `blog_type.rb` substitute the `user_id` field by:
```ruby
field :user, UserType, null: false
```

This will ensure the relation is established and the user type is of UserType (that we already created by doing `rails g graphql:object user`).

We can now do the desired query with no problems.

### What if we want to get all blogs associated to that user?
Imagine we now wanted to get all blogs, each blog showing the user that wrote it but also every blogs associated to that user as well. We want to be able to do a query like this:
```graphql
query Blogs {
  blogs {
    title
    description
    user {
      id
      email
      fullName
      blogs {
        id
        title
      }
    }
  }
}
```

For that, we just need to add the following field to the `user_type.rb`:
```ruby
field :blogs, [BlogType]
``` 

Now we can either get the user associated to a blog, or the blogs associated to a user.

## 7. GraphQL mutations
### 7.1. CREATE
To generate a create mutation, for example to create a new blog, we can use graphql generator in the command line:

```sh
rails g graphql:mutation_create blog
```

This will:
- Create the `blog_create.rb` mutation file within `app/graphql/mutations`;
- Add the ruby code

  ```ruby
  field :blog_create, mutation: Mutations::BlogCreate
  ``` 
  within the `mutation_type.rb` file, creating a field mapped to this resolver for the mutation type, which is present in the `app/graphql/types` folder.

Let's now generate the input attributes that we accept when creating a blog. We can do this using graphql generator as well:
```ruby
rails g graphql:input inputs/create_blog
```

In the created `create_blog_input.rb` file, add the accepted arguments. Also add the `Module Inputs` and change the name of the file and class to `CreateBlogInput`:
```ruby
module Types
  module Inputs
    class CreateBlogInput < Types::BaseInputObject
      description "Attributes for creating a blog"

      argument :title, String, required: true
      argument :description, String, required: false
      argument :user_id, ID, required: true
    end
  end
end
```

Now we just need to edit the mutation resolver to tailor our needs:
```ruby
module Mutations
  class BlogCreate < BaseMutation
    description "Creates a new blog"

    field :blog, Types::Models::BlogType, null: false

    argument :data, Types::Inputs::CreateBlogInput, required: true

    def resolve(data:)
      blog = ::Blog.new(**data)
      raise GraphQL::ExecutionError.new "Error creating blog", extensions: blog.errors.to_hash unless blog.save

      { blog: blog }
    end
  end
end
```

Finally, we are able to do the intended query:
```graphql
mutation CreateBlog($data: CreateBlogInput!) {
  blogCreate(input: { data: $data }) {
    blog {
      createdAt
      description
      id
      title
      updatedAt
    }
  }
}
```

with the variables:
```json
{
  "data": {
    "title": "My New Blog",
    "description": "This is a blog post about GraphQL",
    "userId": 1
  }
}
```

### 7.2. DESTROY
We will follow the same process, but now for destroying a blog:
```sh
rails g graphql:mutation_delete blog
```

The `field :blog_delete, mutation: Mutations::BlogDelete` will automatically be added to the `mutation_type.rb` file.

In the mutation `blog_delete.rb` just add:
```ruby
module Mutations
  class BlogDelete < BaseMutation
    description "Deletes a blog by ID"

    field :blog, Types::Models::BlogType, null: false

    argument :id, ID, required: true

    def resolve(id:)
      blog = ::Blog.find(id)
      raise GraphQL::ExecutionError.new "Error deleting blog", extensions: blog.errors.to_hash unless blog.destroy!

      { blog: blog }
    end
  end
end
```

We can now destroy a blog, as such:
```graphql
mutation DestroyBlog($id: ID!) {
  blogDelete(input: { id: $id }) {
    blog {
      title
      description
    }
  }
}
```
with the id variable:
```json
{
  "id": 23
}
```

### 7.3. UPDATE
Create mutation:
```sh
rails g graphql:mutation_update blog
```

Edit mutation file:
```ruby
module Mutations
  class BlogUpdate < BaseMutation
    description "Updates a blog by id"

    field :blog, Types::Models::BlogType, null: false

    argument :id, ID, required: true
    argument :data, Types::Inputs::UpdateBlogInput, required: true


    def resolve(id:, data:)
      blog = ::Blog.find(id)
      raise GraphQL::ExecutionError.new "Error updating blog", extensions: blog.errors.to_hash unless blog.update(**data)

      { blog: blog }
    end
  end
end
```

Create Input for blog in `update_blog_input.rb`:
```ruby
module Types
  module Inputs
    class UpdateBlogInput < Types::BaseInputObject
      description "Attributes for updating a blog"

      argument :title, String, required: false
      argument :description, String, required: false
      argument :user_id, ID, required: false
    end
  end
end
```

Now we can do the query to update a blog:
```graphql
mutation UpdateBlog($id: ID!, $data: UpdateBlogInput!) {
  blogUpdate(input: { id: $id, data: $data }) {
    blog {
      title
      description
    }
  }
}
```
with variables:
```json
{
  "data": {
    "title": "Newer blog üòÑ"
  },
  "id": 26
}
```

## 8. Authentication with JWT in a Rails API + GraphQL context
### 8.1. Setup
In order to have the authentication functionality up and running, the first thing we need to do is to:
- Comment out the `gem "bcrypt", "~> 3.1.7"` in our gemfile and run `bundle install` in the command line.

We now need to add the `has_secure_password` macro (available within Rails) in our `User` model, which will allow us to encrypt the authentication info of our users:
```ruby
class User < ApplicationRecord
  has_secure_password
  
  has_many :blogs, dependent: :destroy
  has_many :reviews, dependent: :destroy
  
  before_save { self.email = email.downcase }

  def full_name
    "#{first_name} #{last_name}"
  end
end
```

We also need to add the `password_digest` column (String) to the `User` model so that we can store the digested password in our DB in the users table:
```sh
rails g migration AddPasswordDigestToUsers password_digest
```
and run the migration with `rails db:migrate`.

With the `has_secure_password` method we now have access to the `password` and `password_confirmation` instance methods that will allow us to implement the **log in** and **sign up** functionalities.

We just need now to add the `gem 'jwt'` to our gemfile so that we can authenticate our users using JSON Web Tokens. Then run `bundle install` in the command line to install the gem.

### 8.2. Registrations
Let's start by creating an `authentication` folder within our mutations to handle the registrations of users, which will include:
- Creating a registration (sign-up)
- Deleting a registration (cancel account)
- Updating a registration (edits of user account: email, password, etc...)

For now let's focus on the sign-up (we will cover the delete and update at later sections).

#### CREATE
Generate a mutation create for the user:
```sh
rails g graphql:mutation_create user
```

With the mutation created,:
- Move the mutation to the authentication folder;
- Rename the mutation to `registration_create.rb` (and add the module `Authentication` around the class, changing as well the class name to `RegistrationCreate`).
- In the `mutation_type.rb` file, change the auto-generated field to:
  ```ruby
  field :registration_create, mutation: Mutations::Authentication::RegistrationCreate
  ```

Let's also create a folder within our `types/inputs` for the authentication, called `authentication`.
Create the inputs for the registration with:
```sh
rails g graphql:input inputs/authentication/create_registration
```

The input type should look like this:
```ruby
module Types
  module Inputs
    module Authentication
      class CreateRegistrationInput < Types::BaseInputObject
        description "Attributes for creating a registration (user)."

        argument :first_name, String, required: true
        argument :last_name, String, required: true
        argument :email, String, required: true
        argument :password, String, required: true
      end
    end
  end
end
```

Let's now refer to this input type in our mutation:
```ruby
module Mutations
  module Authentication
    class RegistrationCreate < BaseMutation
      description "Registers a new user"

      field :user, Types::Models::UserType, null: false

      argument :data, Types::Inputs::Authentication::CreateRegistrationInput, required: true

      def resolve(data:)
        user = ::User.new(**data)
        raise GraphQL::ExecutionError.new "Error creating user", extensions: user.errors.to_hash unless user.save

        { user: user }
      end
    end
  end
end
```

We are now able to perform the create mutation to create our user registration:
```graphql
mutation RegistrationCreate($data: CreateRegistrationInput!) {
  registrationCreate(input: { data: $data }) {
    user {
      id
      fullName
      email
    }
  }
}
```
with variable `data`:
```json
{
	"data": {
		"firstName": "Test",
		"lastName": "Registration",
		"email": "test@test.com",
		"password": "111111"
	}
}
```

The password will be hashed and salted, and the user will have a `password_digest` value representing its registration information.

### 8.3. Sessions
With the user created, let's now do the login and logout logic with JWT.

#### CREATE (Login)
Let's create a mutation for creating a session with the `mutations/authentication` folder:
```ruby
module Mutations
  module Authentication
    class SessionCreate < BaseMutation
      description "Creates a session for a user and returns a JWToken representing that session"

      field :user, Types::Models::UserType, null: false
      field :token, String, null: false

      argument :data, Types::Inputs::Authentication::CreateSessionInput, required: true

      def resolve(data:)
        user = ::User.find_by(email: data.email)

        if user&.authenticate(data.password)
          token = JWT.encode({user_id: user.id}, ENV["JWT_SECRET"], 'HS256')
          
          { 
            user: user,
            token: token
          }
        else
          raise GraphQL::ExecutionError.new "Invalid credentials."
        end
      end
    end
  end
end
```

In order for this mutation to be feasible, we need to:
- Add the `JWT_SECRET` to the `.env` file (choose the secret you want, eg: 2ydjs7932DdsmH!dsljh$);
- Create the input types (email and password required):
  ```ruby
  module Types
    module Inputs
      module Authentication
        class CreateSessionInput < Types::BaseInputObject
          description "Attributes for creating a session."

          argument :email, String, required: true
          argument :password, String, required: true
        end
      end
    end
  end
  ```

We also need to add the field refering to this mutation to the `mutation_type.rb` file:
```ruby
field :session_create, mutation: Mutations::Authentication::SessionCreate
```

Now we can login, and we will receive a token representing the active session of the user:
```graphql
mutation Login($data: CreateSessionInput!) {
	sessionCreate(input: { data: $data }) {
		user {
			fullName
			email
		}
		token
	}
}
```
with `data` variable:
```json
{
	"data": {
		"email": "test@test.com",
		"password": "111111"
	}
}
```

What we want to do now, is to require authentication before the user can perform any of the actions besides creating a registration or a session. For that, let's create an object to handle the authentication process in the `lib` folder, called `authentication.rb`:
```ruby
module Authentication  
  def self.current_user(request)
    token = request.headers['Authorization'].to_s.split(' ').last
    return unless token

    decoded_token = validate_token(token)

    begin
      User.find(decoded_token[0]&.dig('user_id'))
    rescue ActiveRecord::RecordNotFound
      nil
    end
  end

  def self.decode(token)
    JWT.decode(token, ENV["JWT_SECRET"], true, algorithm: 'HS256')
  end  

  def self.validate_token(token)
    decode(token)
  rescue JWT::DecodeError
    # Handle token decoding errors
    nil
  end
end
```

Now, let's add the context to our `graphql_controller.rb` execute method. It should look like this:
```ruby
class GraphqlController < ApplicationController
  # If accessing from outside this domain, nullify the session
  # This allows for outside API access while preventing CSRF attacks,
  # but you'll have to authenticate your user separately
  # protect_from_forgery with: :null_session

  def execute
    variables = prepare_variables(params[:variables])
    query = params[:query]
    operation_name = params[:operationName]
    context = { current_user: Authentication.current_user(request) }
    result = GraphqlApiSchema.execute(query, variables: variables, context: context, operation_name: operation_name)
    render json: result
  rescue StandardError => e
    raise e unless Rails.env.development?
    handle_error_in_development(e)
  end

  # More code...
end
```

Now we need to protect our queries and mutations. We can do that using the `authorized?` method of the graphql gem, that will run the desired query / mutation only if the method complies with the stated condition. For that, let's create an `authenticated_resolver.rb` and `authenticated_mutation.rb` file, that the protected queries/mutations will inherit from:
- resolver:
  ```ruby
  module Resolvers
    class AuthenticatedResolver < BaseResolver
      def authorized?(*_args)
        raise GraphQL::ExecutionError, 'Authentication required.' unless current_user

        true
      end

      def current_user
        context[:current_user]
      end
    end
  end
  ```
- mutation:
  ```ruby
  module Mutations
    class AuthenticatedMutation < BaseMutation
      def authorized?(*_args)
        raise GraphQL::ExecutionError, 'Authentication required.' unless current_user

        true
      end

      def current_user
        context[:current_user]
      end
    end
  end
  ```

Now just change the inheritance of the protected resolvers/mutations from `BaseResolver` and `BaseMutation` to `AuthenticatedResolver` and `AuthenticatedMutation`, as such:
```ruby
module Resolvers
  class UserResolver < AuthenticatedResolver
    description "Get a user by ID."
    
    argument :user_id, ID, required: true, loads: Types::Models::UserType

    type Types::Models::UserType, null: true
    
    def resolve(user:)
      user
    end
  end
end
```

> üîî **Note**: To now do the queries / mutations protected, we are required to pass in the Authorization headers of our request to the graphql endpoint the JWT token we received when signing up / logging in as a Bearer Token.

### 8.4 EXTRA
#### 8.4.1. Customize GraphQL Error responses
To have more control over the error messages that you will eventually throw to the client, create in the `app/graphql/concerns` folder a module `ExecutionErrorResponder` that uses GraphQL::ExecutionError class from `graphql` gem to raising error messages. This class will add the *‚Äúerrors‚Äù* key to the response. Include the `ExecutionErrorResponder` concern in the `BaseMutation` and `BaseResolver` objects to use the execution_error methods.
```ruby
module ExecutionErrorResponder
  extend ActiveSupport::Concern

  private

  def execution_error(message: nil, extensions: nil, status: :unprocessable_entity, code: 422)
    GraphQL::ExecutionError.new(message, extensions: extensions, options: { status: status, code: code})
  end
end
```

We can now raise this concern if an error occurs:
```ruby
def resolve(data:)
  user = ::User.new(**data)
  raise execution_error(message: "Error creating user", extensions: user.errors.to_hash) unless user.save

  { user: user }
end
```

> üîî **Note**: Change all the other `raise GraphQL::ExecutionError.new ....` for this new error raise with mutations and resolvers alike.

#### 8.4.2. DELETE Session (Logout)
The delete of a session is performed by the client (for example, the React application), deleting the stored JWT from the `localStorage`, for example, if you stored the JWT in it.

#### 8.4.3. DELETE Registration
For deleting a user account, let's first create a mutation to delete it:
```sh
rails g graphql:mutation_delete user
```

Let's now:
- Rename the generated file to `registration_delete.rb`;
- Move it to the `mutations/authentication` folder;
- Change the autogenerated field in the `mutation_type.rb` file to:
  ```ruby
  field :registration_delete, mutation: Mutations::Authentication::RegistrationDelete
  ```
- Add the code to already include pundit authorization and authentication with JWT (and user uuid):
```ruby
# frozen_string_literal: true

module Mutations
  module Authentication
    class RegistrationDelete < AuthenticatedMutation
      description "Deletes a user by ID"
  
      argument :user_id, ID, required: true, loads: Types::Models::UserType
  
      field :user, Types::Models::UserType, null: false
  
      def resolve(user:)
        raise execution_error(message: "Error deleting account.", extensions: user.errors.to_hash) unless user.destroy!
  
        { user: user }
      end

      def authorized?(**args)
        policy = UserPolicy.new(current_user, args[:user])
        raise execution_error(message: 'Not authorized to delete this account.', code: 403, status: :unauthorized) unless super && policy.destroy?
  
        true
      end
    end
  end
end
```
 
Of course, we now need to generate the policy for the user with the `destroy?` method:
```sh
rails g pundit:policy user
```
With the policy being:
```ruby
class UserPolicy < ApplicationPolicy
  # NOTE: Up to Pundit v2.3.1, the inheritance was declared as
  # `Scope < Scope` rather than `Scope < ApplicationPolicy::Scope`.
  # In most cases the behavior will be identical, but if updating existing
  # code, beware of possible changes to the ancestors:
  # https://gist.github.com/Burgestrand/4b4bc22f31c8a95c425fc0e30d7ef1f5

  class Scope < ApplicationPolicy::Scope
    # NOTE: Be explicit about which records you allow access to!
    # def resolve
    #   scope.all
    # end
  end

  def destroy?
    user == record
  end
end
```

Now we can safely destroy our account (only if we are the account user and we are authenticated with the correct token):
```graphql
mutation RegistrationDelete($userId: ID!) {
	registrationDelete(input: { userId: $userId }) {
		user {
			email
			fullName
			id
		}
	}
}
```

#### 8.4.4. UPDATE Registration
To update, let's follow the same steps:
- Create update mutation for user:
```sh
rails graphql:mutation_update user
```
- Update mutation to (rename it to `registration_update.rb` and move it to `mutations/authentication`):
  ```ruby
  module Mutations
    module Authentication
      class RegistrationUpdate < AuthenticatedMutation
        description "Updates a user by id"
    
        field :user, Types::Models::UserType, null: false
    
        argument :user_id, ID, required: true, loads: Types::Models::UserType
        argument :data, Types::Inputs::Authentication::UpdateRegistrationInput, required: true
        argument :current_password, String, required: true
    
        def resolve(user:, data:, current_password:)
          raise execution_error(message: "Wrong password.", extensions: user.errors.to_hash) unless user&.authenticate(current_password)
          raise execution_error(message: "Error updating account.", extensions: user.errors.to_hash) unless user.update(**data)
    
          { user: user }
        end

        def authorized?(**args)
          policy = UserPolicy.new(current_user, args[:user])
          raise execution_error(message: 'Not authorized to update this account.', code: 403, status: :unauthorized) unless super && policy.update?
    
          true
        end
      end
    end
  end
  ```
- Generate `update_registration_input.rb` input type in `types/inputs/authentication`:
  ```ruby
  module Types
    module Inputs
      module Authentication
        class UpdateRegistrationInput < Types::BaseInputObject
          description "Attributes for updating a registration (user)."

          argument :first_name, String, required: false
          argument :last_name, String, required: false
          argument :email, String, required: false
          argument :password, String, required: false
        end
      end
    end
  end
  ```
- Change the autogenerated field in the `mutation_type.rb` file to:
  ```ruby
  field :registration_update, mutation: Mutations::Authentication::RegistrationUpdate
  ```
- Add method `update?` in `User` policy:
  ```ruby
  def update?
    user == record
  end
  ```

We can now update our account info if we are logged in, we are the owner of the account (aka the user) and we provide the correct password:
```graphql
mutation RegistrationUpdate($userId: ID!, $currentPassword: String!, $data: UpdateRegistrationInput!) {
  registrationUpdate(
    input: {
      userId: $userId
      currentPassword: $currentPassword
      data: $data
    }
  ) {
    user {
      email
      firstName
      fullName
      id
      lastName
    }
  }
}
```
with variables:
```json
{
	"data": {
		"firstName": "New",
		"lastName": "Name"
	},
	"currentPassword": "222222",
	"userId": "4365djdshgfjkzgdsi7sd"
}
```

## 9. Pundit Integration with GraphQL
In order to include pundit authorizations within our Rails API + GraphQL app, we just need to ad the `gem 'pundit'` in our gemfile and install it with `bundle install`.

After, we install pundit, that will create for us a `policies` folder and the `application_policy.rb` file that will be the inherited class from our policies:
```sh
rails g pundit:install
```

With that in place, we just need to create the necessary policies, for example, for our `Blog` model:
```sh
rails g pundit:policy blog
```

For the `Blogs` query, we might want the scope to be only the current user blogs. For that, we can define the scope to be:
```ruby
class BlogPolicy < ApplicationPolicy
  # NOTE: Up to Pundit v2.3.1, the inheritance was declared as
  # `Scope < Scope` rather than `Scope < ApplicationPolicy::Scope`.
  # In most cases the behavior will be identical, but if updating existing
  # code, beware of possible changes to the ancestors:
  # https://gist.github.com/Burgestrand/4b4bc22f31c8a95c425fc0e30d7ef1f5

  class Scope < ApplicationPolicy::Scope
    # NOTE: Be explicit about which records you allow access to!
    def resolve
      scope.where(user: user)
    end
  end
end
```

And in our `blogs_resolver.rb`, we add the policy_scope:
```ruby
# frozen_string_literal: true

module Resolvers
  class BlogsResolver < AuthenticatedResolver
    description "Get all blogs."

    type [Types::Models::BlogType], null: false

    def resolve
      Pundit.policy_scope(current_user, ::Blog)
    end
  end
end
```

The first argument being the current user (so that the policy understands the user that it is authorizing) and the second argument the model to be authorized.

If we want to authorize a specific action for a model, for example, the creation fo a blog, we can:
- Add the method `create?` in our blog policy, which for now will just be true, but we can imagine having a `user.admin?` condition:
  ```ruby
  def create?
    true # or user.admin?, etc...
  end
  ```
- Now, we can add the `authorized?` method to our `blog_create.rb` mutation:
  ```ruby
  module Mutations
    class BlogCreate < AuthenticatedMutation
      description "Creates a new blog"

      field :blog, Types::Models::BlogType, null: false

      argument :data, Types::Inputs::CreateBlogInput, required: true

      def resolve(data:)
        blog = ::Blog.new(**data)

        raise execution_error(message: "Error creating blog.", extensions: blog.errors.to_hash) unless blog.save
        
        { blog: blog }
      end

      def authorized?(**args)
        policy = BlogPolicy.new(current_user, nil)
        raise execution_error(message: 'Not authorized to create a blog.', code: 403, status: :unauthorized) unless super && policy.create?

        true
      end
    end
  end
  ```
  The `super` keyword will ensure that the authorization from being logged in (present in our `authenticated_mutation.rb` file) is also verified along with pundit's authorization.

We can also protect our `blog_resolver.rb`, so that the user can only see blogs that he created. For that, let's add the `show?` method in our `blog_policy.rb`:
```ruby
class BlogPolicy < ApplicationPolicy
  # NOTE: Up to Pundit v2.3.1, the inheritance was declared as
  # `Scope < Scope` rather than `Scope < ApplicationPolicy::Scope`.
  # In most cases the behavior will be identical, but if updating existing
  # code, beware of possible changes to the ancestors:
  # https://gist.github.com/Burgestrand/4b4bc22f31c8a95c425fc0e30d7ef1f5

  class Scope < ApplicationPolicy::Scope
    # NOTE: Be explicit about which records you allow access to!
    def resolve
      scope.where(user: user)
    end
  end

  def create?
    true
  end

  def show?
    record.user == user
  end
end
```

Now, in our `blog_resolver.rb` let's also add our `authorized?`method, but now sending:
```ruby
module Resolvers
  class BlogResolver < AuthenticatedResolver
    description "Get a blog by ID."
    
    argument :blog_id, ID, required: true, loads: Types::Models::BlogType

    type Types::Models::BlogType, null: true
    
    def resolve(blog:)
      blog
    end

    def authorized?(**args)
      policy = BlogPolicy.new(current_user, args[:blog])
      raise execution_error(message: 'Not authorized to see this blog.', code: 403, status: :unauthorized) unless super && policy.show?
      
      true
    end
  end
end
```

Now we can only see a blog if it is ours. Authentication from JWT will also be in place.

## References
- [GraphQL Gem](https://graphql-ruby.org/) - GraphQL gem documentation
- [How To GraphQL-Ruby Tutorial](https://www.howtographql.com/graphql-ruby/0-introduction/) - Extensive tutorial on GraphQL gem
- [Data Manipulation: A Dive into GraphQL Mutations in Rails 7 API](https://medium.com/simform-engineering/data-manipulation-a-dive-into-graphql-mutations-in-rails-7-api-bca1f7f00bab) - Mutations deepdive in graphql gem
- [Unlocking GraphQL's Power with Rails: What No One's Told You Yet!](https://www.youtube.com/watch?v=nnHYfNRGFKQ) - Tutorial on implementing GraphQL into Rails, with JWT authentication.
- [Rails magic: has_secure_password](https://medium.com/geekculture/rails-magic-has-secure-password-a9bf0167642d) - has_secure_password information
- [User Authentication by JWT for Rails GraphQL API](https://blog.stackademic.com/user-authentication-by-jwt-for-rails-graphql-api-fa1aa4ba1039) - Registration and Login with JWT within GraphQL Rails API
- [Server-side authentication using GraphQL + JWT + Ruby on Rails](https://medium.flatstack.com/server-side-authentication-using-graphql-jwt-ruby-on-rails-8820e0471ed4) - Authentication with JWT within GraphQL Rails API
# Next.js project with TypeScript, Tailwind, ApolloClient (Client & Server)
## 1. Setup
### 1.1. Create Next.js app
```sh
npx create-next-app@latest
```

### 1.2. Install Apollo
```sh
npm install @apollo/client @apollo/experimental-nextjs-app-support graphql
```

#### Configure Apollo Client for Server Components:
```js
// apollo-client.ts

import { ApolloClient, HttpLink, InMemoryCache } from "@apollo/client";
import { registerApolloClient } from "@apollo/experimental-nextjs-app-support";
import { createServerAuthLink } from '@/lib/apollo-auth-link';
import { headers } from 'next/headers';

// Apollo client for queries:
export const { getClient, query } = registerApolloClient(() => {
  const httpLink = new HttpLink({
    uri: 'http://127.0.0.1:3000/graphql',
  });
  
  const authLink = createServerAuthLink(() => headers().get('x-invoke-path') || '');

  return new ApolloClient({
    cache: new InMemoryCache(),
    link: authLink.concat(httpLink),
  });
});

// Apollo client for mutations:
const httpLink = new HttpLink({
  uri: 'http://127.0.0.1:3000/graphql',
});

const authLink = createServerAuthLink(() => headers().get('x-invoke-path') || '');

export const apolloClient = new ApolloClient({
  cache: new InMemoryCache(),
  link: authLink.concat(httpLink),
});
```

#### Configure Apollo Client for Client Components:
```js
// /lib/apollo_wrapper.tsx
"use client";

import {
  ApolloLink,
  HttpLink,
} from "@apollo/client";

import {
  ApolloNextAppProvider,
  ApolloClient,
  InMemoryCache,
  SSRMultipartLink,
} from "@apollo/experimental-nextjs-app-support";

function makeClient() {
  const httpLink = new HttpLink({
      uri: "http://127.0.0.1:3000/graphql",
  });

  return new ApolloClient({
    cache: new InMemoryCache(),
    link:
      typeof window === "undefined"
        ? ApolloLink.from([
            new SSRMultipartLink({
              stripDefer: true,
            }),
            httpLink,
          ])
        : httpLink,
  });
}

export function ApolloWrapper({ children }: React.PropsWithChildren) {
  return (
    <ApolloNextAppProvider makeClient={makeClient}>{children}</ApolloNextAppProvider>
  );
}
```

#### Add wrapper to layout:
```js
// /app/layout.tsx

import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { ApolloWrapper } from "@/lib/apollo-wrapper";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <ApolloWrapper>{children}</ApolloWrapper>
      </body>
    </html>
  );
}
```

### 1.3. Install codegen to read types from graphql and geneate TypeScript types to frontend:
#### In Rails Api generate rake task to dump graphql schema into a file to be copied to frontend:
```ruby
# /lib/tasks/graphql.rake
#frozen_string_literal: true

require 'graphql/rake_task'

GraphQL::RakeTask.new(schema_name: 'GraphqlApiSchema')
```
Run task to generate `schema.graphql` file:
```sh
rails graphql:schema:dump
```

#### Install codegen in frontend app:
```sh
npm add graphql                              
npm add typescript @graphql-codegen/cli
```

#### Copy backend generated `schema.graphql` to frontend `/graphql`
#### Create `/graphql/codegen.yml` with following configuration:
```yml
---
overwrite: true
schema: graphql/schema.graphql
documents: graphql/*/*.graphql

generates:
  graphql/generated.tsx:
    plugins:
      - typescript
      - typescript-operations
      - typed-document-node
      # - typescript-react-apollo
    config:
      documentVariableSuffix: 'Doc'
```
Create script to run codegen configuration and generate types file:
```json
// package.json
  ...
  "scripts": {
    ...
    "codegen": "npx graphql-codegen --config graphql/codegen.yml"
  },
```

#### Now let's create some queries and mutations (placed them under `graphql/queries`, `graphql/mutations` and `graphql/fragments`)
```graphql
query Blogs {
  blogs {
    id
    title
    description
    user {
      email
      fullName
    }
  }
}
```

#### Now generate the types by running the pnpm command:
```sh
npm run codegen
```

# 2. Get all blogs
Now let's create a route for the `/blogs` endpoint by generating a folder `blogs` with a `page.tsx` file that will be rendering the page. It will be a server component:
```js
import { Blog, BlogsDoc } from "@/graphql/generated";
import { query } from "@/lib/apollo-client";
import Link from "next/link";

export default async function BlogsPage() {
  const { data } = await query({query: BlogsDoc});

  return (
    <div className="mx-5">
      <h1 className="text-4xl mt-5 mb-5 text-center">MY BLOGS</h1>

      <ul>
        {data.blogs.map((blog: Blog, idx: number) => {
          return <li key={idx}><Link href={`/blogs/${blog.id}`} className="hover:text-orange-800">{blog.title}</Link></li>
        })}
      </ul>
    </div>
  )
}
```

# 3. Authentication:
## 3.1. Create LoginForm component:
```js
"use client"

import React from 'react';
import { login } from '@/actions/auth';
import { useFormState } from "react-dom";

function LoginForm() {
  const [state, formAction] = useFormState(login)
  return (
    <form action={formAction}>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" name="email" type="email" placeholder="Email" />
      </div>
      <div>
        <label htmlFor="password">Password</label>
        <input id="password" name="password" type="password" />
      </div>
      <button type="submit">Login</button>
      <p>{state?.error}</p>
    </form>
  )
}

export default LoginForm;
```

## 3.2. Generate the signup function
It will be a server action sending the request and storing the jwtToken in the cookies:
```js
// /actions/auth.ts
"use server"

import { LoginDoc } from "@/graphql/generated";
import { apolloClient } from "@/lib/apollo-client";
import { cookies } from 'next/headers'
import { redirect } from "next/navigation";

export async function login(state: any, formData: FormData) {
  try {
    const { data } = await apolloClient.mutate({
      mutation: LoginDoc, 
      variables: {
        data: {
          email: formData.get("email"),
          password: formData.get("password")
        }
      }
    })
    
    cookies().set('jwtToken', data.sessionCreate.token)
  } catch(error: any) {
    return { error: error.message }
  }

  redirect("/blogs")
}
```

## 3.3. Validate and refresh jwtToken (backend) [NOT NEEDED!!!]
Let's now create in our backend an endpoint to validate the jwtToken and refresh it for a newer one if it is valid.
1. Add e session_validate.rb in our mutations folder, that will fetch user if token is valid and refresh to a new token:
```ruby
module Mutations
  module Authentication
    class SessionValidate < BaseMutation
      description "Validates the JWToken and refreshes for a new one"

      field :user, Types::Models::UserType, null: false
      field :token, String, null: false

      argument :token, String, required: true

      def resolve(token:)
        user = ::Authentication.current_user_from_token(token)
        
        if user
          token = JWT.encode({user_id: user.id, exp: Time.now.to_i + 86_400}, ENV["JWT_SECRET"], 'HS256')

          { 
            user: user,
            token: token
          }
        else
          raise execution_error(message: "Invalid jwtToken.", code: 401, status: :unauthorized)
        end
      end
    end
  end
end
```

2. Add the mutation to the `mutation_type.rb` file:
```ruby
field :session_validate, mutation: Mutations::Authentication::SessionValidate
```

## 3.4. Frontend:
1. Follow steps of codegen to regenerate the schema of graphql, add the ahtentication mutation to frontend:
```js
mutation Authenticate($token: String!) {
	sessionValidate(input: { token: $token }) {
		token
		user {
			email
			fullName
			id
		}
	}
}
```

2. Add an auth error (when jwt token doesnt exist or the response is invalid token, we redirect to /login)
```js
// lib/auth_error.ts
import { redirect } from 'next/navigation';

export function handleAuthError(error: unknown) {
  if (error instanceof Error) {
    if (error.message === 'JWT_MISSING' || error.message.includes('Invalid token')) {
      redirect('/login');
    }
  }
  throw error;
}
```